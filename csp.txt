Common Serialization Protocol (CSP)

  CSP is the protocol of serialization that provide fast serialization
  process, with low memory consumption.  It supports versioning of
  Interfaces, work in different compatibility modes (flexibility), and
  versioning of protocol with backward compatibility (extensibility).
  Also CSP provide client-server data exchange mechanism.

  Central role in CSP is occupied by CSP Message.  It is the data that
  is packed by CSP handling.

  CSP Messaging process is the client-server interaction in CSP model.
  In case of simple saving/restoring data from storage medium there is
  no need in Messaging, but still data is packed in Message format.
  
  Any program, no matter if it is driver or daemon, or user app, which
  is interact with CSP implementation, is called User Application.

  Instead of use expression "serialization/deserialization process" here
  we often will use Serialization keyword (with "S" capitalized) for
  brevity.  But when serialization word is using with the small letter
  "s" it is meaning serialization process only.
  
  The data which is processed during Serialization is packaged as
  structures.  In most of the times we intentionally using word
  "structs" instead of "types" because the only things that matters to
  us is data that is holding in structure and it relative position
  inside "struct", and don't care about this type behavior.
  
  Bits ordering of distinct octets in the schemes has big endian
  format.
  
  Some examples will include C notation.

Message Format

  Message has three main parts: Common Context, Private Context and
  Private Body.  Private parts are usually named by Message Type.
  So instead of saying Private Context or Private Body of Data Message
  we are saying Data Context or Data Body.
  
  CSP Message Format
       
            |  64 bits long |Variable length|Variable length|
            +---------------+---------------+---------------+
            | Common Context|Private Context|  Private Body |
            |               |   (optional)  |   (optional)  |
            +---------------+---------------+---------------+
           
                                Figure 1
           
  Availibility of Private Context and Private Body, and also their
  formats, depends on Message Type.


Common Context Format

  Start of any Message include Common Context part.  It has fixed length
  of 64 bits. Fields included here affect on all Private Parts of the
  Message.
  
  CSP Common Context Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  CSP version  |    Reserved   |          Message Type         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Common Flags                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 2
                                
  All fields of CSP Common Context are always presented in little-endian
  format.
  
  CSP version: 8 bits
  
    Version of protocol using in Message creation and client-server
    interactions.  
    
    Current version is 1 (still in development).
    Possible values 1-254.
    
    Value 255 have special meaning - Protocol Version Undefined.
    Value 0 is not using.
    
  Reserved: 8 bits
  
    Reserved for future use.  Must be zero.
    
  Message Type: 16 bits
  
    Type of Message.
    
    0: Status
    1: Data
    2: GetSettings
    
  Common Flags: 32 bits
  
    Options that have common meaning to Private parts of Message.
    
    Bit 0 (0x1): bitness of system on which serialization is performed
      is 32 bit (when not set is 64 bits).
    Bit 1 (0x2): using big endian format (default endianness is
      little-endian.
    Bit 2 (0x4): there was endianness difference of "using big endian
      format" flag and execution environment where serialization
      performed.
    Bits 3-31: unused (reserved, must be zero).

Private parts

  Private parts structure depends on Message Type.

Status Message

  Status Messages are sends in Messaging process, in several cases.
  That will be discused in Messaging section.
  
  Status Context

  CSP Status Context Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Status                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 3

  Status: 32 bits
  
    Status of operation.  Status with positive values are Informational,
    with negative are errors.
    
    Note that status codes may and should be used not only in Messages,
    but as result of internal procedures that participate in all
    CSP procesing, for transparency.  In the following list desctiptions
    of codes will be provided mostly for directly related to CSP
    routines.

    0: NoError; operation is successed

    1: NoFurtherProcessingRequired; if operation is not the latest in
      some operation sequence, subsequent operations must be skipped.

    -1: ErrorNoMemory; there was not enough memory to complete the
      operation.

    -2: ErrorOverflow; general meanings in CSP:
      - there was mismatch in deserialization process in size of
      deserialized data with expected one;
      - serialized or deserialized data exceeds target or curren
      environment limits.

    -3: ErrorInvalidArgument; lights inconsistence of input arguments in
      CSP procedures.  For instance, if there is recursive pointers flag
      was set and no pointers map container is supplied to serialization
      procedure an error will be detected.  Such error most likely tell
      about design of User Application issue.

    -4: ErrorNotSupportedProtocolVersion; protocol version that need to
      use in Serialization is not supported by this instance.

    -5: ErrorNotSupportedInterfaceVersion; Interface version that need
      to use in Serialization or Messaging is not supported by this
      instance, or client, or server.

    -6: ErrorInvalidHash.

    -7: ErrorMismatchOfProtocolVersions.

    -8: ErrorMismatchOfInterfaceVersions.

    -9: ErrorMismatchOfStructId; struct id that is deserialized not
      correspond to that which is expect.

    -10: ErrorNoSuchHandler; there is no procedure or server that can
      handle the request.

    -11: ErrorInternal; in general any internal error that indicate of
      CSP implementation design isuue.  But it is also may be result
      of not properly configured Serialization related procedures for
      User Application specific structs.

    -12: ErrorNotSupportedSerializationSettingsForStruct; internal error
      which indicate that some of settings are not suitable for current
      struct.  Normally it may be used for implementing some logic and
      it should not go as return value to User Application.

    -13: ErrorInvalidType; there is inconsistence of struct and actions
      that intend to apply to it.  May witness of internal errors, but
      mostly it is not properly configured Serialization related
      procedures for User Application specific structs.

    -14: ErrorDataCorrupted; returns when there is possibility of data
      corruption in Serialization.  But there is also can be internal
      error in CSP implementation which was lead to this condition.
      
    -15: ErrorNotCompatibleCommonFlagsSettings; if some of the common
      flags have mutual contradictory status.
      
    -16: ErrorNotCompatibleDataFlagsSettings; if some of the data flags
      have mutual contradictory status.

    -17: ErrorMoreEntires; implementation specific status, currently may
      be using only in CSP internal procedures.
      
    -18: ErrorNotInited; party that use CSP is not inited.
      
    -19: ErrorNoSupportedInterfaces; using in Messaging to indicate
      that there is no common CSP Interfaces between client and server.
      
    -20: ErrorNotSupportedInterface; using in Messaging to indicate
      that client struct that should be handled is from Interface that
      is not supported by client or server.
      
      
  Status Body
  
  Length and format depends on status Field.  Only the few Status values
  require Body field.

  ErrorNotSupportedProtocolVersion:

    CSP ErrorNotSupportedProtocolVersion Status Body Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Size of CSP  |                  CSP versions                 |
    |    versions   |                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    \                          CSP versions                         \
    \                                                               \
    |                                                               |                     
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
                                Figure 4

    Size of CSP versions: 1 octet
      
      Size of field CSP versions.
        
    CSP versions: 1-254 octet
      
      Versions must be sorted in decreasing order, latest version is
      first.

  Other statuses:
    
    Does not have Status Body part.

Data Message

  Data Messages are the central part of CSP protocol.  This messages
  include endpoint data that should be serialized and vice versa.
  
  Data Context Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Struct ID                           +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Interface version                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Data flags                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 5

  Struct ID: 128 bits
  
    It represents UUIDv4 of the stuct that take part in Serialization.
    
  Interface version: 32 bits
  
    Version of Interface on which current struct was serialized.
    There will be distinct section with Interface definition.
    
  Data flags: 32 bits

    Options that will affect on Data Body processing.
    
    Bit 0 (0x1): alignment may be not equal.
      
      Alignment of structs that take a part in Data Body in modules that
      serialize and deserialize Message, may be not equal.
      
      If this flag is not set some optimizations of Serialization can be
      made.  In particular instead of process some struct field-by-field
      one can use plain memory copy of entire object, of course this
      struct must be simply assignable (not using pointers etc).
      
    Bit 1 (0x2): size of primitives may be not equal.
    
      Indicated that there is possibility of that the compilers that
      built modules that take a part in Serialization may interpret with
      different size any of the primitives fields.  What is primitive in
      CSP point of view will be discussed later.
      
    Bit 2 (0x4): allow unmanaged pointers.
    
      In standard processing any pointer that is a part of some
      serialized struct must be managed by it and Serialization process
      must include individual procedures to handle it.
      Any free pointer is threaten as error and no serialization must
      be done.
      
      This flag removes this restriction and allow Serialization of
      pointers on generic order.  Of course any such pointer must point
      to one and only one object instance.  Handling this pointers is up
      to specific implementation.
      
    Bit 3 (0x8): check recursive pointers.
      In general form there must not be any recursive link in serialized
      struct.  But if architecture of Interface of User Application is
      allows it, additional check must be made and this flag is indicate
      this task.
      
      Protocol oblige check recursive pointers mode work only with
      unmanaged pointers.  So if CSP implementation does not expand this
      edges to managed pointers, allow unmanaged pointers must be set
      when flag is used.
   
    Bits 4-31: unused (reserved, must be zero).

  Data Body
  
    It is binary form of serialized struct data which is produced
    with respect of Common and Data Contexts.
    
    Concrete rules and principles of Serialization process will be
    discussed in the same name section.
    
GetSettings Message

  GetSettings Message is sends by client in Messaging process when he
  want to know capabilities and restrictions of server including
  supported Interfaces.
  
  This Message has ho Context and Body.
  
  In response to this Message server must send CspPartySettings struct.
  Its definition will be presented in Special Structs Interface section.


CSP Interfaces

  By CSP Interface we mean the set of structures where every one have
  several interface properties and several individual properties.  If 
  we say that some instance is supported specific Interface of specific
  version number, than it means that it has snapshot of every struct in
  this Interface that is on that version.
  
Interface properties
  
  Interface ID
  
    UUIDv4 of the struct interface.
    
  Version
  
    32 bits field, that represents current version of interface.  Its
    semantic depends on concrete interface.  This is the only field that
    allowed to be changed.
    
  Mandatory data flags
  
    Data flags that are always in use in Serialization of interface
    structs.
    
  Forbidden data flags
  
    Data flags that cannot be used in Serialization of interface
    structs.
  
Structures individual properties
(applied to those that are part of any CSP Interface)

  Struct ID
  
    UUIDv4 of struct itself. Cannot be changed.
    
  Struct Interface version
  
    Version of interface on which current struct or one of its
    dependecies were changed last time.  Dependencies mean substructs
    (fields) from which this one consists.
    
  Private versions

    An array of interface versions values.  Value is added every time 
    when struct was changed.  Sorted in decreasing order.
    
    By change we mean adding or removing field from struct or from one
    of struct parents (structs are allowed to be inherited), or when one
    of the struct field changed its type (structure).  It is important
    to note, that only change of field type (structure) is lead to
    Private version update.  If there is internal change of field struct
    (update), private version wouldn't change, instead interface version
    is changed. 
    
  Additional mandatory data flags (optional)
  
    Data flags that are always in use in Serialization of this struct.
    It is dijunction of every additional mandatory data flags of every
    struct dependency and struct private restrictions.
    Effective mandatory data flags set is disjunction of mandatory data
    flags and additional mandatory data flags.
    
  Additional forbidden data flags (optional)
  
    Data flags that cannot be used in Serialization of this struct.
    It is dijunction of every additional forbidden data flags of every
    struct dependency and struct private restrictions.
    Effective forbidden data flags set is disjunction of forbidden data
    flags and additional forbidden data flags.
  
Types that are in use in CSP Interfaces

  It is important to say that structs in concrete interface are allowed
  to be made of types that are not part of this interface.  And there is
  two distinct scenarios.
  
  First, when type (struct) is not part of any CSP interface - it has no
  CSP Interface properties and it is not allowed to version conversion.
  Also such types cannot be as root struct in CSP Data Message, only as
  field of struct from CSP interface.  Example of such types are
  integers, floating point numbers and any user-defined composite types.
  
  Second, struct from parent interface.  More details will be in 
  Dependent Interfaces section.
  
Dependent Interfaces

  CSP allows to inherit interfaces.  But descendant interfaces are have
  one and only one parent.  It must have the same versioning order as
  parent have.  Start Version property is the same as Struct Interface
  version property of the most recent changed struct from parent
  interface that is a part of derived interface as dependency, or the
  most recent Version property.
  
  Every time when dependency from parent interface is updated Version of
  derived interface must be updated too (and all dependent Struct
  Interface versions).
  
  Derived interface don't allowed to have versions bigger than parent
  interface has, but parent one don't have any such restrictions.  So if
  there is need to add or update any of derived interface struct, and
  the derived interface before this update has the same version as the
  parent one, than need to wait before parent interface will be updated.
  
Data that can be serialized by CSP

  Primitives
    
    Integers and floating point numbers.
    
  Pointers (references on most languages other than C++)
  
    Pointers on primitives, structures, another pointers.
  
  Arrays
  
    Arrays of primitives, pointers, structures.
  
  Structures (objects)
  
    Structures are built from primitives, pointers, other structures,
    and their arrays in ordered form.
    They can be multiple inherited.
    Also struct can have one of special CSP tags that can optimize
    Serialization process.
   
Structures tags

  Empty type tag
  
    Struct has no serializable fields.  This type no need to serialize
    at all.  This can be the case with some special structs, and when
    such struct is parent or member of another struct that is
    serialized.
    
  Simply assignable tag
  
    Struct holds its data only in primitives, arrays of primitives and
    another structures with the same properties.  If there is guaranty
    that data exchange will be between CSP instances with the same
    sizing of primitives and alignment of struct parts is also the same,
    such struct can be serialized by raw copy.  If we use C-language,
    than it is possible to express by this sentence:
      memcpy(serialized_data, &struct, sizeof(struct))
    
  Simply assignable aligned to one tag
    
    The same meaning as just simply assignable tag, but there is no
    restrictions of CSP instance alignment settings, because such
    structs must be aligned to 1 on every interface implementation.
    
  Simply assignable fixed size tag
  
    The same meaning as Simply assignable tag but here is guaranty that
    all primitive fields of struct have fixed size in any implementation
    and all composite types of any other fields in struct must also
    match this restriction.  Struct that have this tag are not
    restricted be copied be memcpy() even if Data Flag Size of
    arithmetic types may be not equal is set.
    
  Always simply assignable tag
    
    The same meaning as Simply assignable fixed size tag but here is
    alignment to 1 must be implied.  These structs always have the same
    size and the same fields and sub-fields offsets.
  
  Struct has no tag
  
    Struct must be Serialized field-by-field no matter of other options.
    
Structures on CSP view

  Imagine next structs scheme:
  
      +---------------------------------------------------------+
      | Struct A                Struct B                        |
      |   integer i               A a                           |
      |   pointer to int pi       array of int size 3 ai        |
      |                                                         |
      | Struct C                Struct D inherits B and C       |
      |   array of A size 2 aa    pointer to pointer to int ppi |
      |                           integer j                     |
      +---------------------------------------------------------+
        
                                Scheme 1
                                
  Here we can decompose Struct D as:
  
      +---------------------------------------------------------+
      | Struct D                                                |
      |   Stuct B b                                             |
      |   Struct C c                                            |
      |   pointer to pointer to int ppi                         |
      |   integer j                                             |
      +---------------------------------------------------------+
      
                                Scheme 2
                                
  Order by which we do it is matter.  First, we get parent one - b,
  then parent two - c, and after that field one - ppi and field two - j.
  So we can say that we have 4 fields, and we must process them each
  with Serialization function.
  
  But if Struct has one of the tags that allows to not decompose it in
  current Serialization context (defined by set of acting flags), then
  we are consider it as raw memory chunk:

      +---------------------------------------------------------+
      | Struct E                                                |
      |   integer x                                             |
      |   integer y                                             |
      |                                                         |
      |   Simply_assignable_tag                                 |
      +---------------------------------------------------------+
      
                                Scheme 3
                                
  So, if integer size is 4 octets, than whole E size is 8 octets and we
  can copy 8 raw octets to Data Body if we Serializing E instance.
  
  But despite that, if you wish to use in your CSP Interface some
  specific compatibility modes, you still need to have ability of
  Serialize it field-by-field.
  
How data is serialized

  CSP has quite a lot of flexibility in this question.  It depends on
  structures tags, Common and Data flags.  Next sections will go into
  deep on processing each type of data that is can be Serialized.  Pay
  attention that that rules are applied to Data Context and Data Body
  sections.
  
Serialization of Primitives

  No flags are set
  
    The primitive is copied octet-to-octet according to how it is
    defined in the current execution environment.  So if we return to
    Struct E from Scheme 3 and serilize it field-by-field, than we will
    get two integers that are resides one right after another in memory
    just as in original struct.  And if Struct E is top-struct, then all
    Data Body will be 8 octet sized.
    
    The only exception is special size_t type which will be described in
    the subsection bellow.
    
  Common Flag Bitness is 32
  
    There is one special primitive, that intentionally has different
    length in x64 and x32 environments.  It's named as in C-language
    size_t.  It has length of address space.  Every CSP Interface that
    wish to Serialize types where size_t-like primitives are present
    (containers for example), must explicitly mark that this type is
    size_t.  How this mark should be done is implementation defined.
    
    If bitness on Serialization processes differs from current machine,
    then additional checks of fields of size_t types must be taken.
    
    If execution environment is x64 and 32 bitness flag is set.
    
      On serialization every size_t field must be checked, that it not
      exceeds 32 bits boundaries and write to Data Body its 4 low
      octets, otherwise operation must return status ErrorOverflow.
      
      Total size of Message must not exceed 2^32 octets.

    If execution environment is x32 and 32 bitness flag is not set.
      
      On serialization of size_t field it should be appended by high 4
      zero octets field (it should be written as 8 octet integer with
      value of size_t).  
      
      On deserialization implementation must read 8 octets of every 
      size_t field and check that it not exceeds current implementation
      boundary, otherwise operation must return status ErrorOverflow.
      
  Common Flag Big endian format
  
    If execution environment endianness setting is differ from this flag
    value, then bytes of primitive reversation must be done.
      
  Data Flag Size of arithmetic types may be not equal
  
    Different environments where Serialization is performed may include
    such where some primitives sizes are not equal between each other.
    The most frequent example is most of C/C++ fundamental data types
    where their specific length is not guarantied by the standard.  The
    main advice to handle such situations - do not use definitions of
    primitives with such types in your CSP Interfaces.  The only 
    exception is the size_t type which is handled in a special way (read
    just above).  But if for any reason you must implement your
    Interface with violating this recomendation and environments where
    Serialization is performed are different - use this flag with
    affected structs Serialization.
    
    When this flag is set, and primitive type is potentially has 
    different lengths (not every types can have different lengths - 
    double floating point, for example), on serialization it must be
    prepended with 1 octet that holds this type size in octets.
    
Serialization of Pointers

  Data Flag Allow unmanaged pointers
  
    This flag allows generic processing of unmanaged pointers.  So if
    some struct has pointer type field and has no custom function to
    handle it, then this pointer will be dereferenced and Serialized
    with a few special rules.
    
      - if pointer has value nullptr, then octet with value of 0 is
        written, and value of 1 is written otherwise;
        
      - if pointer points to another pointer and so on, it will be
        dereferenced until we get type on which "final" pointer pointed;
        
      - type on which "final" pointer is pointed is Serialized as usual;
        for example, if we have pointer to pointer to integer, then at
        the very end we get an integer that will be processed as
        primitive which it is.
        
    Example
    
      +---------------------------------------------------------+
      | Struct F                                                |
      |   pointer to pointer to integer ppi1                    |
      |   pointer to pointer to integer ppi2                    |
      +---------------------------------------------------------+
      
                                Scheme 4
    
    Concede we have following values:
    
      **f.ppi1 = 4;
      *f.ppi2 = nullptr;
      
    For those of you who do not familiar with C pointers notation, this
    mean that on the first field integer to which points pointer to
    which points pointer to pointer to integer have value of 4, and on 
    the second field pointer to integer to which points pointer to
    pointer has value of nullptr.
    
    We are serializing 'f'.
    
    Data Body content (bytes order is little endian)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 1|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 6
    
    Content description:
    
      0 octet: 1 - pointer to pointer to int (f.ppi1) is not nullptr.
        
      Then f.ppi1 dereferenced and recursively:
      
      1 octet: 1 - pointer to int is not nullptr.
    
      Again, recursively pointer to int derefernced:
    
      2-5 octets: 4 - value of int.
    
      6 octet: 1 - pointer to pointer to int (f.ppi2) is not nullptr.

      Then f.ppi2 dereferenced and recursively:
    
      7 octet: 0 - pointer to int is nullptr.
    
  Data Flag Check recursive pointers
  
    Some structs can hold pointers in form of cycle graph.  To prevent
    infinite cycles of Serialization care of such pointers must be
    taken.  We remind you that protocol obliges to check only free
    pointers when using this flag.  However specific implementation can
    expand this borders.
    
    In serialization process every time when affected pointer is
    serialized it must be prepended with one of the next size_t values:
    
      0: if pointer is nullptr
      
      1: if this is new pointer
      
      offset from begining of Message: if this is pointer that already
      was serialized
      
    Only new pointer is futher serialized.
    
    If Allow unmanaged pointers flag is also set (which is true by
    default), then rules of prepended values applies only related to
    Check recursive pointers.  That is - free pointers are not prepended
    with additional octet.
    
    Example
    
      +---------------------------------------------------------+
      | Struct G                                                |
      |   pointer to integer pi1                                |
      |   pointer to pointer to integer ppi                     |
      |   pointer to integer pi2                                |
      |   pointer to integer pi3                                |
      |                                                         |
      | integer i                                               |
      +---------------------------------------------------------+
      
                                Scheme 5
                                
    Concede we have following values:
    
      integer i = 4
      
      g.pi1 = &i
      g.ppi = &g.pi
      g.pi2 = &i
      g.pi3 = nullptr
      
    We are serializing 'g'.
    
    Data Body content (bytes order is little endian and system is x32
    for brevety, because size_t is 4 octets length in such systems)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 1 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16  0 0 1 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 7
                                
    Content description:
    
      0-3 octets: 1 - g.pi1 is new pointer (not serialized yet)
      
      Dereferencing g.pi1
      
      4-7 octets: 4 - the value of i (to which points g.pi)
    
      8-11 octets: 1 - g.ppi is new pointer
      
      Dereferncing ppi
    
      12-15 octets: 36 - offset from Message begin to place where type
        to which points g.pi1 (integer i) was serialized.
        32 octets is for Common and Data Contexts, plus 4 to get to 4-7
        octets.
      
      16-19 octets: 36 - offset from Message begin to place where
        pointer to i already was serialized (when g.pi1 was serialized).
      
      20-23 octets: 0 - g.pi3 is nullptr
      
    Note must be taken that every size_t field (0-3, 8-23 octets) would
    be 8 octets long on when Common Flag Bitness is 32 is not set.
    
  Other flags configurations
  
    Serialization is allowed only when pointer is managed (owned) by
    some object and its (objects) Serialization function is not generic.
    Managed pointer is always have number of elements to which it
    points and unmanaged is not.
    
    Every managed pointer serialization starts with placing number of
    elements first (as size_t).  If pointer is nullptr number is equal
    to 0.  Next, pointer data is serialized by the following rules: 
    
      If type on which points pointer is an Empty Type, nothing is
      serialized.
      
      If Common Flag Big endian format settings is the same as in
      execution environment
        and
      (If type on which points pointer is primitive
        or
      this type is not part of CSP Interface or current Serialization
      process is not in interface versions not match mode (will be
      defined later)
        and
      Type   has Always simply assignable tag)
          or has Simply assignable fixed size tag and there is no
             alignment may be not equal flag set
          or has Simply assignable aligned to one tag and there is no
             size of primitives may be not equal flag set
          or has Simply assignable tag and there is no alignment may be
             not equal and primitives may be not equal flags set)

        then all data on which points pointer is copied as raw array of
        octets and if there is Size of primitives may be not equal flag
        set (can be only if pointer points on primitive), then this data
        is prepended by size of primitive type on which points pointer.
    
      All other cases - every element is dereferenced and serialized
      individulally.
      
    Example
    
      +---------------------------------------------------------+
      | Struct H                                                |
      |   Empty_type_tag                                        |
      |                                                         |
      | Struct K                                                |
      |   8_bits_integer i                                      |
      |   32_bits_integer j                                     |
      |   Simply_assignable_tag                                 |
      |                                                         |
      | Struct L                                                |
      |   size_t sizeI                                          |
      |   pointer to integer pi                                 |
      |                                                         |
      | Struct M                                                |
      |   8_bits_integer sizeH                                  |
      |   pointer to H ph                                       |
      |   size_t sizeI                                          |
      |   pointer to i pi                                       |
      |   size_t sizeJ                                          |
      |   pointer to i pj                                       |
      |   size_t sizeK                                          |
      |   pointer to K pk                                       |
      |   size_t sizeL                                          |
      |   pointer to L pL                                       |
      +---------------------------------------------------------+
      
                                Scheme 6
                                
    Concede we have following values:
    
      integer arr1[1] = { 3 }
      integer arr2[1] = { 4 }
      integer arr3[2] = { 5, 6 }
      
      H h[5]
      
      K k[2]
      k[0].i = 10
      k[0].j = 32
      k[1].i = 15
      k[1].j = 5
      
      L l[2]
      l[0].sizeI = 1
      l[0].pi = arr2
      l[1].sizeI = 2
      l[1].pi = arr3
      
      M m
      m.sizeH = 5
      m.ph = h
      m.sizeI = 1
      m.pi = arr1
      m.sizeJ = 0
      m.pj = nullptr
      m.sizeK = 2
      m.pk = k
      m.sizeL = 2
      m.pl = l
    
    We are serializing 'm'. No flags are set.
     
    Data Body content (bytes order is little endian and system is x32
    for brevety, because size_t is 4 octets length in such systems)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 1 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 24 |0 0 1 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 27
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 28 |0 0 0 0 1 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 31
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 32 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 35
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 36 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 39
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 40 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 43
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 44 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 47
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 48 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 51
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 52 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 55
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 56 |0 0 0 0 0 1 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 59
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 8
    
    Content description:
    
      0-3 octets: m.ph elements count
        Note that despite that m.sizeH is octet long we serializing not
        its value, but exactly m.ph elements count, and thanks to this
        we have no need to serialize m.sizeH field value separately.
      
      Next field m.ph don't serialized itself as it has Empty_type_tag      
      
      4-7 octets: m.pi elements count
      
      8-11 octets: dereferenced m.pi value (arr1[1])
      
      12-15 octets: m.pj elements count
      
      Next field m.pj don't serialized itself as m.sizeJ == 0
      
      16-19 octets: m.pk elements count
      
      20-35 octets: data on which points m.pk field (copied by memcpy
        since K has Simply_assignable_tag)
       
        Note that because of the aligning 8_bits_integer i field is
        expanded to 4 octets, full K struct size is 8 octets.
        
      36-39 octets: m.pl elements count
      
      40-47 octets: m.pl[0] element
        40-43: count of m.pl[0].pi elements
        44-47: m.pl[0].pi[0] 
      
      48-59 octets: m.pl[1] element
        48-51: count of m.pl[1].pi elements
        52-55: m.pl[1].pi[0] 
        55-59: m.pl[1].pi[1]
    
Serialization of Arrays

  Any flags settings
  
    Arrays are Serialized by almost the same rules as managed pointers.
    (see Other flags configurations subsection) but instead read "type
    on which points pointer" we read "type of array elements".  The only
    difference is in prepended size_t number which is absent in 
    Serialization of arrays.  As arrays have strict defined size already,
    then we do not need to write it size to Data Body.
    
    Example
  
      +---------------------------------------------------------+
      | Struct N                                                |
      |   array of integers arri[1]                             |
      |                                                         |
      | Struct O                                                |
      |   array of H arrh[5]                                    |
      |   array of integers arri[1]                             |
      |   array of K arrk[2]                                    |
      |   array of N arrl[2]                                    |
      +---------------------------------------------------------+
      
                                Scheme 7
                                
    Concede we have following values:
    
      O o
      0.arri = { 3 }
      0.arrk[0].i = 10
      0.arrk[0].j = 32
      0.arrk[1].i = 15
      0.arrk[1].j = 5
      0.arrn[0].arri = { 4 }
      0.arrn[1].arri = { 5 }
    
    We are serializing '0'. No flags are set.
     
    Data Body content (bytes order is little endian)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 1 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 1 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 0 0 1 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 24 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 27
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 9
                            
    Content description:
    
      o.arrh is not serialized, as H has Empty_type_tag
      
      0-3 octets: o.arri content (copied by memcpy since o.arri is an
        array of primitives)

      4-19 octets: o.arri content (copied by memcpy since K has 
        Simply_assignable_tag)
       
        Note that because of the aligning 8_bits_integer i field is
        expanded to 4 octets, full K struct size is 8 octets.
        
      20-23 octets: o.arrn[1].arri (copied by memcpy since N.arri is an
        array of primitives)
        
      24-27 octets: o.arrn[2].arri (copied by memcpy since N.arri is an
        array of primitives)
      
      Pay attention that we do not serialized o.arrn field all at once
      because Struct N does not have Simply_assignable_tag (generally
      speaking, giving the type of its single field it can have it (tag)
      but it haven'tm for the sake of current example).
        
Copyright (c) 2023-2024 Andrey Grabov-Smetankin <ukbpyh@gmail.com>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.