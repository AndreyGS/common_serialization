Common Serialization Protocol (CSP)

  CSP is the protocol of serialization that provide fast serialization
  process, with low memory consumption.  It supports versioning of
  Interfaces, work in different compatibility modes (flexibility), and
  versioning of protocol with backward compatibility (extensibility).
  Also CSP provide client-server data exchange mechanism.

  Central role in CSP is occupied by CSP Message.  It is the data that
  is packed by CSP handling.

  CSP Messaging process is the client-server interaction in CSP model.
  In case of simple saving/restoring data from storage medium there is
  no need in Messaging, but still data is packed in Message format.
  
  Any program, no matter if it is driver or demon, or user app, which is
  interact with CSP implementation, is called User Application.

  Instead of use serialization/deserialization process sentense here we
  will use Serialization keyword for brevity.
  

Message Format

  Message has three main parts: Common Context, Private Context and
  Private Body.  Private parts are usually named by Message Type.
  So instead of saying Private Context or Private Body of Data Message
  we are saying Data Context or Data Body.
  
  CSP Message Format
       
            |  64 bits long |Variable length|Variable length|
            +---------------+---------------+---------------+
            | Common Context|Private Context|  Private Body |
            |               |   (optional)  |   (optional)  |
            +---------------+---------------+---------------+
           
                                Figure 1
           
  Availibility of Private Context and Private Body, and also their
  formats, depends on Message Type.


Common Context Format

  Start of any Message include Common Context part.  It has fixed length
  of 64 bits. Fields included here affect on all Private Parts of the
  Message.
  
  CSP Common Context Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  CSP version  |    Reserved   |          Common Flags         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Message Type                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 2
                                
  All fields of CSP Common Context are always presented in little-endian
  format.
  
  CSP version: 8 bits
  
    Version of protocol using in Message creation and client-server
    interactions.  
    
    Current version is 1 (still in development).
    Possible values 1-254.
    
    Value 255 have special meaning - Protocol Version Undefined.
    Value 0 is not using.
    
  Reserved: 8 bits
  
    Reserved for future use.  Must be zero.
    
  Common Flags: 16 bits
  
    Options that have common meaning to Private parts of Message.
    
    Bit 0: using big endian format (default endianess is little-endian.
    Bit 1: there is possibility of endian difference.
    Bits 2-15: unused (reserved, must be zero).
 
  Message Type: 32 bits
  
    Type of Message.
    
    0x0: Status
    0x1: Data
    0x2: InOutData
    0x3: CommonCapabilitiesRequest


Private parts

  Private parts structure depends on Message Type.

Status Message

  Status Messages are sends in Messaging process, in several cases.
  That will be discused in Messaging section.
  
  Status Context

  CSP Status Context Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Status                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 3

  Status: 32 bits
  
    Status of operation.  Status with positive values are Informational,
    with negative are errors.
    
    Note that status codes may and should be used not only in Messages,
    but as result of internal procedures that participate in all
    CSP procesing, for transparency.  In the following list desctiptions
    of codes will be provided mostly for directly related to CSP
    routines.

    0: NoError; operation is successed

    1: NoFurtherProcessingRequired; if operation is not the latest in
      some operation sequence, subsequent operations must be skipped.

    -1: ErrorNoMemory; there was not enough memory to complete the
      operation.

    -2: ErrorOverflow; general meaning in CSP - there was mismatch in
      deserialization process in size of deserialized data with expected
      one.

    -3: ErrorInvalidArgument; lights inconsistence of input arguments in
      CSP procedures.  For instance, if there is recursive pointers flag
      was set and no pointers map container is supplied to serialization
      procedure an error will be detected.  Such error most likely tell
      about design of User Application issue.

    -4: ErrorNotSupportedProtocolVersion; protocol version that need to
      use in Serialization is not supported by this instance.

    -5: ErrorNotSupportedInterfaceVersion; interface version that need to
      use in Serialization is not supported by this instance.

    -6: ErrorInvalidHash.

    -7: ErrorMismatchOfProtocolVersions.

    -8: ErrorMismatchOfInterfaceVersions.

    -9: ErrorMismatchOfStructId; struct id that is deserialized not
      correspond to that which is expect.

    -10: ErrorNoSuchHandler; there is no procedure or server that can
      nandle the request.

    -11: ErrorInternal; in general any internal error that indicate of
      CSP implementation design isuue.  But it is also may be result
      of not properly configured Serialization related procedures for
      User Application specific structs.

    -12: ErrorNotSupportedSerializationSettingsForStruct; internal error
      which indicate that some of settings are not suitable for current
      struct.  Normally it may be used for implementing some logic and
      it should not go as return value to User Application.

    -13: ErrorInvalidType; there is inconsistence of struct and actions
      that intend to apply to it. May witness of internal errors, but
      mostly it is not properly configured Serialization related
      procedures for User Application specific structs.

    -14: ErrorDataCorrupted; returns when there is possibility of data
      corruption in Serialization.  But there is also can be internal
      error in CSP implementation which was lead to this condition.
      
    -15: ErrorNotCompatibleFlagsSettings; if some of the Contexts flags
      have mutual contradictory status.

    -16: ErrorMoreEntires; implementation specific status, currently may
      be using only in CSP internal procedures.
      
    -17: ErrorNotSupportedInOutInterfaceVersion; using in Messaging,
      when server cannot process InOutData Message because if either
      input or output struct have incompatible versions.
      
  Status Body
  
  Length and format depends on status Field.  Only the few Status values
  require Body field.

  ErrorNotSupportedProtocolVersion:

    CSP ErrorNotSupportedProtocolVersion Status Body Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Size of CSP  |                  CSP versions                 |
    |    versions   |                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    \                          CSP versions                         \
    \                                                               \
    |                                                               |                     
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
                                Figure 4

    Size of CSP versions: 1 octet
      
      Size of field CSP versions.
        
    CSP versions: 1-254 octet
      
      Versions must be sorted in decreasing order, latest version is
      first.

  ErrorNotSupportedInOutInterfaceVersion:

    CSP ErrorNotSupportedInOutInterfaceVersion Status Body Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Input struct minimum supported interface version       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Input struct maximum supported interface version       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Output struct minimum supported interface version       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Output struct maximum supported interface version       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
                                Figure 5

    Full body size of ErrorNotSupportedInOutInterfaceVersion is 128
      bits.
      
      
    Each field of ErrorNotSupportedInOutInterfaceVersion Body represents
    respective versions of coresponding structs.  Details of what
    Interface versions are and how they handled in CSP will be discussed
    later.

  Other statuses:
    
    Does not have Status Body part.


Data Message

  Data Messages are the central part of CSP protocol.  This messages
  include endpoint data that should be serialized and vice versa.
  
  Data Message Context

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Struct ID                           +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Data flags                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Interface version                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 6

  Struct ID: 128 bits
  
    It represents UUIDv4 of the stuct that take part in Serialization.
    
  Data flags: 32 bits

    Options that will influence on Data Body processing.
    
    Bit 0: alignment may be not equal.
      
      Alignment of structs that take a part in Data Body in modules that
      serialize and deserialize Message, may be not equal.
      
      If this flag is not set some optimizations of Serialization can be
      made. In particular instead of process some struct field-by-field
      one can use plain memory copy of entire object, of course this
      struct must be simply assignable (not using pointers etc).
      
    Bit 1: size of arithmetic types may be not equal.
    
      Indicated that there is possibility of that the compilers that
      built modules that take a part in Serialization may interpret with
      different size any of the arithmetic (fundamental) fields from
      which consists data struct.


Copyright (c) 2023-2024 Andrey Grabov-Smetankin <ukbpyh@gmail.com>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.