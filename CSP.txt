Common Serialization Protocol (CSP)
==================================

  CSP is the protocol of serialization that provide fast serialization
  process, with low memory consumption.  It supports versioning of
  structures, work in different compatibility modes (flexibility), and
  versioning of protocol itself with backward compatibility
  (extensibility).  Also CSP provide client-server data exchange
  mechanism.

  Central role in CSP is occupied by CSP Message.  It is the data that
  is packed by CSP handling.

  CSP Messaging process is the client-server interaction in CSP model.
  In case of simple saving/restoring data from storage medium there is
  no need in Messaging, but still data is packed in Message format.
  
  Any program, no matter if it is driver or daemon, or user app, which
  is interact with CSP implementation, is called User Application.

  Instead of use expression "serialization/deserialization process" here
  we often will use Serialization keyword (with "S" capitalized) for
  brevity.  But when serialization word is using with the small letter
  "s" it is meaning serialization process only.
  
  The data which is processed during Serialization is packaged as
  structures.  In most of the times we intentionally using word
  "structs" instead of "types" because the only things that matters to
  us is data that is holding in structure and it relative position
  inside "struct", and don't care about this type behavior.
  
  Bits ordering of distinct octets in the schemes has big endian
  format.
  
  Some examples will include C notation.

Message format
==============

  Message has three main parts: Common Context, Private Context and
  Private Body.  Private parts are usually named by Message Type.
  So instead of saying Private Context or Private Body of Data Message
  we are saying Data Context or Data Body.
  
  CSP Message format
       
            |  64 bits long |Variable length|Variable length|
            +---------------+---------------+---------------+
            | Common Context|Private Context|  Private Body |
            |               |   (optional)  |   (optional)  |
            +---------------+---------------+---------------+
           
                                Figure 1
           
  Availibility of Private Context and Private Body, and also their
  formats, depends on Message Type.


Common Context format
=====================

  Start of any Message include Common Context part.  It has fixed length
  of 64 bits. Fields included here affect on all Private Parts of the
  Message.
  
  CSP Common Context format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  CSP version  |    Reserved   |          Message Type         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Common Flags                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 2
                                
  All fields of CSP Common Context are always presented in little-endian
  format.
  
  CSP version: 8 bits
  
    Version of protocol using in Message creation and client-server
    interactions.  
    
    Current version is 1 (still in development).
    Possible values 1-254.
    
    Value 255 have special meaning - Protocol Version Undefined.
    Value 0 is not using.
    
  Reserved: 8 bits
  
    Reserved for future use.  Must be zero.
    
  Message Type: 16 bits
  
    Type of Message.
    
    0: Status
    1: Data
    2: GetSettings
    
  Common Flags: 32 bits
  
    Options that have common meaning to Private parts of Message.
    
    Bit 0 (0x1): bitness of system on which serialization is performed
      is 32 bit (when not set is 64 bits).
    Bit 1 (0x2): using big endian format (default endianness is
      little-endian.  This flag is take effect only on primitives that
      are larger than 1 byte.
    Bit 2 (0x4): there was endianness difference of "using big endian
      format" flag and execution environment where serialization was
      performed.
    Bits 3-31: unused (reserved, must be zero).

Private parts
==============

  Private parts structure depends on Message Type.

Status Message
==============

  Status Messages are sends in Messaging process, in several cases.
  That will be discused in Messaging section.
  
  Status Context

  CSP Status Context format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Status                             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 3

  Status: 32 bits
  
    Status of operation.  Status with positive values are Informational,
    with negative are errors.
    
    Note that status codes may and should be used not only in Messages,
    but as result of internal procedures that participate in all
    CSP procesing, for transparency.  In the following list desctiptions
    of codes will be provided mostly for directly related to CSP
    routines.

    0: NoError; operation is successed

    1: NoFurtherProcessingRequired; if operation is not the latest in
      some operation sequence, subsequent operations must be skipped.

    -1: ErrorNoMemory; there was not enough memory to complete the
      operation.

    -2: ErrorOverflow; general meanings in CSP - there was mismatch in
      deserialization process in size of deserialized data with
      the expected one.

    -3: ErrorInvalidArgument; lights inconsistence of input arguments in
      CSP procedures.  For instance, if there is recursive pointers flag
      was set and no pointers map container is supplied to serialization
      procedure an error will be detected.  Such error most likely tell
      about design of User Application issue.

    -4: ErrorNotSupportedProtocolVersion; protocol version that need to
      use in Serialization is not supported by this instance.

    -5: ErrorNotSupportedInterfaceVersion; Interface version that need
      to use in Serialization or Messaging is not supported by this
      instance, or client, or server.

    -6: ErrorInvalidHash.

    -7: ErrorMismatchOfProtocolVersions.

    -8: ErrorMismatchOfInterfaceVersions.

    -9: ErrorMismatchOfStructId; struct id that is deserialized not
      correspond to that which is expect.

    -10: ErrorNoSuchHandler; there is no procedure or server that can
      handle the request.

    -11: ErrorInternal; in general any internal error that indicate of
      CSP implementation design isuue.  But it is also may be result
      of not properly configured Serialization related procedures for
      User Application specific structs.

    -12: ErrorNotSupportedSerializationSettingsForStruct; internal error
      which indicate that some of settings are not suitable for current
      struct.  It may be used internal for implementing some logic.
      Another use case is presented is section "Structures tags".

    -13: ErrorInvalidType; there is inconsistence of struct and actions
      that intend to apply to it.  May witness of internal errors, but
      mostly it is not properly configured Serialization related
      procedures for User Application specific structs.

    -14: ErrorDataCorrupted; returns when there is possibility of data
      corruption in Serialization.  But there is also can be internal
      error in CSP implementation which was lead to this condition.
      
    -15: ErrorNotCompatibleCommonFlagsSettings; if some of the common
      flags have mutual contradictory status.
      
    -16: ErrorNotCompatibleDataFlagsSettings; if some of the data flags
      have mutual contradictory status.

    -17: ErrorMoreEntires; implementation specific status, currently may
      be using only in CSP internal procedures.
      
    -18: ErrorNotInited; party that use CSP is not inited.
      
    -19: ErrorNoSupportedInterfaces; using in Messaging to indicate
      that there is no common CSP Interfaces between client and server.
      
    -20: ErrorNotSupportedInterface; using in Messaging to indicate
      that client struct that should be handled is from Interface that
      is not supported by client or server.
      
    -21: ErrorTypeSizeIsTooBig; size of integral that need to be
      processed is exceeded maximum integral size in current
      implementation.
      
    -22: ErrorValueOverflow; returns if Serialized integral have
      different size in source and destination and its value in one of
      its forms is exceeds maximum value that can be hold by another
      one.
      
      
  Status Body
  
  Length and format depends on status Field.  Only the few Status values
  require Body field.

  ErrorNotSupportedProtocolVersion:

    CSP ErrorNotSupportedProtocolVersion Status Body Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Size of CSP  |                  CSP versions                 |
    |    versions   |                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    \                          CSP versions                         \
    \                                                               \
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
                                Figure 4

    Size of CSP versions: 1 octet
      
      Size of field CSP versions.
        
    CSP versions: 1-254 octets
      
      Versions must be sorted in decreasing order, latest version is
      first.
      
  ErrorNotSupportedInterfaceVersion:
  
    CSP ErrorNotSupportedInterfaceVersion Status Body Format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |              Minimum supported Interface version              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                       Output Struct ID                        +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    Minimum supported Interface version: 4 octets
    
      Minimum version of CSP Interface that concrete handler on Server
      supports.
      
    Output Struct ID: 16 otets
    
      UUIDv4 of the stuct that is returning by Server handler when
      Data Message would be correctly processed.  This field using in
      order to make sure of Server handler output capabilities.

  Other statuses:
    
    Does not have Status Body part.

Data Message
============

  Data Messages are the central part of CSP protocol.  This messages
  include endpoint data that should be serialized and vice versa.
  
  Data Context format

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Struct ID                           +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                       Interface version                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Data flags                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 5

  Struct ID: 128 bits
  
    It represents UUIDv4 of the stuct that take part in Serialization.
    
  Interface version: 32 bits
  
    Version of CSP Interface on which current struct was serialized.
    There will be distinct section with CSP Interface definition.
    
  Data flags: 32 bits

    Options that will affect on Data Body processing.
    
    Bit 0 (0x1): alignment may be not equal.
      
      Alignment of structs that take a part in Data Body in modules that
      serialize and deserialize Message, may be not equal.
      
      If this flag is not set some optimizations of Serialization can be
      made.  In particular instead of process some struct field-by-field
      one can use plain memory copy of entire object, of course this
      struct must be simply assignable (not using pointers etc).
      
    Bit 1 (0x2): size of integers may be not equal.
    
      Indicated that there is possibility of that the compilers that
      built modules that take a part in Serialization may interpret with
      different size any of the integers fields.
      
    Bit 2 (0x4): allow unmanaged pointers.
    
      In standard processing any pointer that is a part of some
      serialized struct must be managed by it and Serialization process
      must include individual procedures to handle it.
      Any free pointer is threaten as error and no serialization must
      be done.
      
      This flag removes this restriction and allow Serialization of
      pointers on generic order.  Of course any such pointer must point
      to one and only one object instance.  Handling this pointers is up
      to specific implementation.
      
    Bit 3 (0x8): check recursive pointers.
      In general form there must not be any recursive link in serialized
      struct.  But if architecture of Interface of User Application is
      allows it, additional check must be made and this flag is indicate
      this task.
      
      Protocol oblige check recursive pointers mode work only with
      unmanaged pointers.  So if CSP implementation does not expand this
      edges to managed pointers, allow unmanaged pointers must be set
      when flag is used.
   
    Bit 4 (0x10): simply assignable tags optimizations are turned off.
      Turns of all optimizations of "simply assignable" tags. Must be
      used when dealing with CSP implementations that does not support
      such (like Java, for instance).
    
    Bits 5-31: unused (reserved, must be zero).

  Data Body
  
    It is binary form of serialized struct data which is produced
    with respect of Common and Data Contexts.
    
    Concrete rules and principles of Serialization process will be
    discussed in the same name section.
    
GetSettings Message
===================

  GetSettings Message is sends by client in Messaging process when he
  want to know capabilities and restrictions of server including
  supported Interfaces.
  
  This Message has no Private Context and Body.
  
  In response to this Message server must send CspPartySettings struct
  packed in Data Message.  Its definition will be presented in Special
  Structs Interface section.

Data that can be serialized by CSP
==================================

  Primitives
    
    Integers: 1, 2, 4 and 8 octets length;
    Floating point numbers: IEEE 754 single-precision and
    double-precision formats.

    There can be any other formats of integral and floating-point
    numbers defined in specific implementations but they are not part of
    current standard.

    Generally speaking there is no hard restrictions on support any
    primitive type, but considering that CSP must work in different
    operational modes there is no reason to expand supported list more,
    for now.

  Pointers (references on most languages other than C++)
  
    Pointers on primitives, structures, another pointers.
  
  Arrays
  
    Arrays of primitives, pointers, structures.
  
  Structures (objects)
  
    Structures are built from primitives, pointers, other structures,
    and their arrays in the ordered form.
    They can be multiple inherited.
    Also struct can have one of special CSP tags that can optimize
    Serialization process.
    Data Messages are always contain a single Top-struct, which itself
    can hold any others data (depending on its internal structure).
    This Top-struct is must to belong to one of CSP Interfaces.
   
Structures tags
===============

  Empty type tag
  
    Struct has no serializable fields.  This type no need to serialize
    at all.  This can be the case with some special structs, and when
    such struct is parent or member of another struct that is
    serialized.
    
  Simply assignable tag
  
    Struct holds its data only in primitives, arrays of primitives and
    another structures with the same properties.  If there is guaranty
    that data exchange will be between CSP instances with the same
    sizing of primitives and alignment of struct parts is also the same,
    such struct can be serialized by raw copy.  If we use C-language,
    than it is possible to express by this sentence:
      memcpy(serialized_data, &struct, sizeof(struct))
    
  Simply assignable aligned to one tag
    
    The same meaning as just simply assignable tag, but there is no
    restrictions of CSP instance alignment settings, because such
    structs must be aligned to 1 on every interface implementation.
    
  Simply assignable fixed size tag
  
    The same meaning as Simply assignable tag but here is guaranty that
    all primitive fields of struct have fixed size in any implementation
    and all composite types of any other fields in struct must also
    match this restriction.  Struct that have this tag are not
    restricted be copied be memcpy() even if Data Flag Size of
    arithmetic types may be not equal is set.
    
  Always simply assignable tag
    
    The same meaning as Simply assignable fixed size tag but here is
    alignment to 1 must be implied.  These structs always have the same
    size and the same fields and sub-fields offsets.
    
  Endianness tolerant tag
  
    If struct have no primitive in its fields, subfields, parent fields
    etc. that are influenced to endianness changes according to CSP view
    (read "using big endian format" Common flag description), then it
    can be marked with this tag. 
  
  Struct has no tag
  
    Struct must be Serialized field-by-field no matter of other options.
    
  Note that any of simply assignable tags can be implied only when
  structure is not containing any kind of virtual tables.  So if
  environment where CSP is running is implying virtual tables to every
  struct (like Java, for instance) no symply assignable tags
  optimizations can be made and "simply assignable tags optimizations 
  are turned off" Data Flag must be set when interacting with such CSP
  instance.  If at the same time CSP implementation does not have
  distinct Serialization function to current operation with type that
  have any of such tags ErrorNotSupportedSerializationSettingsForStruct
  status must be returned.
    
Structures in the CSP view
==========================

  Imagine next structs scheme:
  
      +---------------------------------------------------------+
      | Struct A                Struct B                        |
      |   integer i               A a                           |
      |   pointer to int pi       array of int size 3 ai        |
      |                                                         |
      | Struct C                Struct D inherits B and C       |
      |   array of A size 2 aa    pointer to pointer to int ppi |
      |                           integer j                     |
      +---------------------------------------------------------+
        
                                Scheme 1
                                
  Here we can decompose Struct D as:
  
      +---------------------------------------------------------+
      | Struct D                                                |
      |   Stuct B b                                             |
      |   Struct C c                                            |
      |   pointer to pointer to int ppi                         |
      |   integer j                                             |
      +---------------------------------------------------------+
      
                                Scheme 2
                                
  Order by which we do it is matter.  First, we get parent one - b,
  then parent two - c, and after that field one - ppi and field two - j.
  So we can say that we have 4 fields, and we must process them each
  with Serialization function.
  
  But if Struct has one of the tags that allows to not decompose it in
  current Serialization context (defined by set of acting flags), then
  we are consider it as raw memory chunk:

      +---------------------------------------------------------+
      | Struct E                                                |
      |   integer x                                             |
      |   integer y                                             |
      |                                                         |
      |   Simply_assignable_tag                                 |
      +---------------------------------------------------------+
      
                                Scheme 3
                                
  So, if integer size is 4 octets, than whole E size is 8 octets and we
  can copy 8 raw octets to Data Body if we Serializing E instance.
  
  But despite that, if you wish to use in your CSP Interface some
  specific compatibility modes, you still need to have ability of
  Serialize it field-by-field.
  
How data is serialized
======================

  CSP has quite a lot of flexibility in this question.  It depends on
  structures tags, Common and Data flags.  Next sections will go into
  deep on processing each type of data that is can be Serialized.  Pay
  attention that that rules are applied to Data Context and Data Body
  sections.
  
Serialization of Primitives
===========================

  No flags are set
  
    The primitive is copied octet-to-octet according to how it is
    defined in the current execution environment.  So if we return to
    Struct E from Scheme 3 and serilize it field-by-field, than we will
    get two integers that are resides one right after another in memory
    just as in original struct.  And if Struct E is Top-struct, then all
    Data Body will be 8 octet sized.
    
    The only exception is special size_t type which will be described in
    the subsection bellow.
    
  Common Flag Bitness is 32
  
    There is one special primitive, that intentionally has different
    length in x64 and x32 environments.  It's named as in C-language
    size_t.  It has length of address space.  Every CSP Interface that
    wish to Serialize types where size_t-like primitives are present
    (containers for example), must explicitly mark that this type is
    size_t.  How this mark should be done is implementation defined.
    
    If bitness on Serialization processes differs from current machine,
    then additional checks of fields of size_t types must be taken.
    
    If execution environment is x64 and 32 bitness flag is set.
    
      On serialization every size_t field must be checked, that it not
      exceeds 32 bits boundaries and write to Data Body its 4 low
      octets, otherwise operation must return status ErrorValueOverflow.
      
      Total size of Message must not exceed 2^32 octets.

    If execution environment is x32 and 32 bitness flag is not set.
      
      On serialization of size_t field it should be appended by high 4
      zero octets field (it should be written as 8 octet integer with
      value of size_t).  
      
      On deserialization implementation must read 8 octets of every 
      size_t field and check that it not exceeds current implementation
      boundary, otherwise operation must return status
      ErrorValueOverflow.
      
  Common Flag Big endian format
  
    If execution environment endianness setting is differ from this flag
    value, for each primitive that is larger than 1 octet, bytes
    reversation must be done.
      
  Data Flag Size of integer types may be not equal
  
    Different environments where Serialization is performed may include
    such where some integers sizes are not equal between each other.
    The most frequent example is most of C/C++ fundamental data types
    where their specific length is not guarantied by the standard.  The
    main advice to handle such situations - do not use definitions of
    integers with such types in your CSP Interfaces.  The only 
    exception is the size_t type which is handled in a special way (read
    just above).  But if for any reason you must implement your
    Interface with violating this recomendation and environments where
    Serialization is performed are different - use this flag with
    affected structs Serialization.
    
    When this flag is set, and integers type is potentially has 
    different lengths, on serialization it must be  prepended with 1
    octet that holds this type size in octets.
    
Serialization of Pointers
=========================

  Data Flag Allow unmanaged pointers
  
    This flag allows generic processing of unmanaged pointers.  So if
    some struct has pointer type field and has no custom function to
    handle it, then this pointer will be dereferenced and Serialized
    with a few special rules.
    
      - if pointer has value nullptr, then octet with value of 0 is
        written, and value of 1 is written otherwise;
        
      - if pointer points to another pointer and so on, it will be
        dereferenced until we get type on which "final" pointer pointed;
        
      - type on which "final" pointer is pointed is Serialized as usual;
        for example, if we have pointer to pointer to integer, then at
        the very end we get an integer that will be processed as
        primitive which it is.
        
    Example
    
      +---------------------------------------------------------+
      | Struct F                                                |
      |   pointer to pointer to integer ppi1                    |
      |   pointer to pointer to integer ppi2                    |
      +---------------------------------------------------------+
      
                                Scheme 4
    
    Consider we have following values:
    
      **f.ppi1 = 4;
      *f.ppi2 = nullptr;
      
    Here we are using C-style pointers notation.
    
    We are serializing 'f'.
    
    Data Body content (bytes order is little endian)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 1|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 6
    
    Content description:
    
      0 octet: 1 - pointer to pointer to int (f.ppi1) is not nullptr
        
      Then f.ppi1 dereferenced and recursively:
      
      1 octet: 1 - pointer to int is not nullptr
    
      Again, recursively pointer to int derefernced
    
      2-5 octets: 4 - value of int
    
      6 octet: 1 - pointer to pointer to int (f.ppi2) is not nullptr

      Then f.ppi2 dereferenced and recursively:
    
      7 octet: 0 - pointer to int is nullptr
    
  Data Flag Check recursive pointers
  
    Some structs can hold pointers in form of cycle graph.  To prevent
    infinite cycles of Serialization care of such pointers must be
    taken.  We remind you that protocol obliges to check only free
    pointers when using this flag.  However specific implementation can
    expand this borders.
    
    In serialization process every time when affected pointer is
    serialized it must be prepended with one of the next size_t values:
    
      0: if pointer is nullptr
      
      1: if this is new pointer
      
      offset from begining of Message: if this is pointer that already
      was serialized
      
    Only new pointer is futher serialized.
    
    If Allow unmanaged pointers flag is also set (which is true by
    default), then rules of prepended values applies only related to
    Check recursive pointers.  That is - free pointers are not prepended
    with additional octet.
    
    Example
    
      +---------------------------------------------------------+
      | Struct G                                                |
      |   pointer to integer pi1                                |
      |   pointer to pointer to integer ppi                     |
      |   pointer to integer pi2                                |
      |   pointer to integer pi3                                |
      |                                                         |
      | integer i                                               |
      +---------------------------------------------------------+
      
                                Scheme 5
                                
    Consider we have following values:
    
      integer i = 4
      
      g.pi1 = &i
      g.ppi = &g.pi
      g.pi2 = &i
      g.pi3 = nullptr
      
    We are serializing 'g'.
    
    Data Body content (bytes order is little endian and system is x32
    for brevety, because size_t is 4 octets length in such systems)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 1 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16  0 0 1 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 7
                                
    Content description:
    
      0-3 octets: 1 - g.pi1 is new pointer (not serialized yet)
      
      Dereferencing g.pi1
      
      4-7 octets: 4 - value of i (to which points g.pi)
    
      8-11 octets: 1 - g.ppi is new pointer
      
      Dereferncing ppi
    
      12-15 octets: 36 - offset from Message begin to place where type
        to which points g.pi1 (integer i) was serialized.
        32 octets is for Common and Data Contexts, plus 4 to get to 4-7
        octets.
      
      16-19 octets: 36 - offset from Message begin to place where
        pointer to i already was serialized (when g.pi1 was serialized).
      
      20-23 octets: 0 - g.pi3 is nullptr
      
    Note must be taken that every size_t field (0-3, 8-23 octets) would
    be 8 octets long on when Common Flag Bitness is 32 is not set.
    
  Other flags configurations
  
    Serialization is allowed only when pointer is managed (owned) by
    some object and its (objects) Serialization function is not generic.
    Managed pointer is always have number of elements to which it
    points and unmanaged is not.
    
    Every managed pointer serialization starts with placing number of
    elements first (as size_t).  If pointer is nullptr number is equal
    to 0.  Next, pointer data is serialized by the following rules: 
    
      If type on which points pointer is an Empty Type, nothing is
      serialized.
      
      If Common Flag Big endian format settings is the same as in
      execution environment or current type is endianness tolerant
        and
      (If type on which points pointer is primitive
        or
      simply assignable tags optimizations are turned off
          and
        this type is not part of CSP Interface or its version less or
        equal to context interface version)
          and
        Type has Always simply assignable tag)
            or has Simply assignable fixed size tag and there is no
               alignment may be not equal flag set
            or has Simply assignable aligned to one tag and there is no
               size of integers may be not equal flag set
            or has Simply assignable tag and there is no alignment may
             be not equal and integers may be not equal flags set
      )

        then all data on which points pointer is copied as raw array of
        octets and if there is Size of integers may be not equal flag
        set (can be only if pointer points on integers), then this data
        is prepended by size of integers type on which points pointer.
    
      All other cases - every element is dereferenced and serialized
      individulally.
      
    Example
    
      +---------------------------------------------------------+
      | Struct H                                                |
      |   Empty_type_tag                                        |
      |                                                         |
      | Struct K                                                |
      |   8_bits_integer i                                      |
      |   32_bits_integer j                                     |
      |   Simply_assignable_tag                                 |
      |                                                         |
      | Struct L                                                |
      |   size_t sizeI                                          |
      |   pointer to integer pi                                 |
      |                                                         |
      | Struct M                                                |
      |   8_bits_integer sizeH                                  |
      |   pointer to H ph                                       |
      |   size_t sizeI                                          |
      |   pointer to i pi                                       |
      |   size_t sizeJ                                          |
      |   pointer to i pj                                       |
      |   size_t sizeK                                          |
      |   pointer to K pk                                       |
      |   size_t sizeL                                          |
      |   pointer to L pL                                       |
      +---------------------------------------------------------+
      
                                Scheme 6
                                
    Consider we have following values:
    
      integer arr1[1] = { 3 }
      integer arr2[1] = { 4 }
      integer arr3[2] = { 5, 6 }
      
      H h[5]
      
      K k[2]
      k[0].i = 10
      k[0].j = 32
      k[1].i = 15
      k[1].j = 5
      
      L l[2]
      l[0].sizeI = 1
      l[0].pi = arr2
      l[1].sizeI = 2
      l[1].pi = arr3
      
      M m
      m.sizeH = 5
      m.ph = h
      m.sizeI = 1
      m.pi = arr1
      m.sizeJ = 0
      m.pj = nullptr
      m.sizeK = 2
      m.pk = k
      m.sizeL = 2
      m.pl = l
    
    We are serializing 'm'. No flags are set.
     
    Data Body content (bytes order is little endian and system is x32
    for brevety, because size_t is 4 octets length in such systems)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 1 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 24 |0 0 1 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 27
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 28 |0 0 0 0 1 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 31
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 32 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 35
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 36 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 39
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 40 |0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 43
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 44 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 47
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 48 |0 0 0 0 0 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 51
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 52 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 55
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 56 |0 0 0 0 0 1 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 59
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 8
    
    Content description:
    
      0-3 octets: m.ph elements count (in size_t format)
        Note that despite that m.sizeH is octet long we serializing not
        its value, but exactly m.ph elements count, and thanks to this
        we have no need to serialize m.sizeH field value separately.
      
      Next field m.ph don't serialized itself as it has Empty_type_tag      
      
      4-7 octets: m.pi elements count (in size_t format)
      
      8-11 octets: dereferenced m.pi value (arr1[1])
      
      12-15 octets: m.pj elements count (in size_t format)
      
      Next field m.pj don't serialized itself as m.sizeJ == 0
      
      16-19 octets: m.pk elements count (in size_t format)
      
      20-35 octets: data on which points m.pk field (copied by memcpy
        since K has Simply_assignable_tag)
       
        Note that because of the aligning 8_bits_integer, after i field
        3 padding octets are added and full K struct size is 8 octets.
        
      36-39 octets: m.pl elements count (in size_t format)
      
      40-47 octets: m.pl[0] element
        40-43: count of m.pl[0].pi elements
        44-47: m.pl[0].pi[0] 
      
      48-59 octets: m.pl[1] element
        48-51: count of m.pl[1].pi elements
        52-55: m.pl[1].pi[0] 
        55-59: m.pl[1].pi[1]
    
Serialization of Arrays
=======================

  Any flags settings
  
    Arrays are Serialized by almost the same rules as managed pointers.
    (see Other flags configurations subsection) but instead read "type
    on which points pointer" we read "type of array elements".  The only
    difference is in prepended size_t number which is absent in 
    Serialization of arrays.  As arrays have strict defined size already,
    then we do not need to write it size to Data Body.
    
    Example
  
      +---------------------------------------------------------+
      | Struct N                                                |
      |   array of integers arri[1]                             |
      |                                                         |
      | Struct O                                                |
      |   array of H arrh[5]                                    |
      |   array of integers arri[1]                             |
      |   array of K arrk[2]                                    |
      |   array of N arrl[2]                                    |
      +---------------------------------------------------------+
      
                                Scheme 7
                                
    Consider we have following values:
    
      O o
      0.arri = { 3 }
      0.arrk[0].i = 10
      0.arrk[0].j = 32
      0.arrk[1].i = 15
      0.arrk[1].j = 5
      0.arrn[0].arri = { 4 }
      0.arrn[1].arri = { 5 }
    
    We are serializing 'o'. No flags are set.
     
    Data Body content (bytes order is little endian)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 1 0 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 1 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 0 0 1 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 24 |0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 27
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
                                Figure 9
                            
    Content description:
    
      o.arrh is not serialized, as H has Empty_type_tag
      
      0-3 octets: value of o.arri (copied by memcpy since o.arri is an
        array of primitives)

      4-19 octets: value of o.arri (copied by memcpy since K has 
        Simply_assignable_tag)
       
        Note that because of the aligning 8_bits_integer i field is
        expanded to 4 octets, full K struct size is 8 octets.
        
      20-23 octets: value of o.arrn[1].arri (copied by memcpy since N.arri is an
        array of primitives)
        
      24-27 octets: value of o.arrn[2].arri (copied by memcpy since N.arri is an
        array of primitives)
      
      Pay attention that we do not serialized o.arrn field all at once
      because Struct N does not have Simply_assignable_tag (generally
      speaking, giving the type of its single field it can have it (tag)
      but it haven'tm for the sake of current example).
      
Serialization of Structures
===========================

  For common rules go to "Structures in the CSP view" section.
  
    Example
    
    Consider we have following values:
    
      D d (Scheme 2)
      
      integer i1 = 4
      integer i2 = 9
      integer i3 = 11
      integer i4 = 12
      pointer to integer pi = &i4
      
      d.a.i = 3
      d.a.pi = &i1
      d.ai = { 5, 6, 7 }
      d.aa[0].i = 8
      d.aa[0].pi = &i2
      d.aa[1].i = 10
      d.aa[1].pi = &i3
      d.ppi = &pi
      d.j = 15
      
    We are serializing 'd'. Data Flag Allow unmanaged pointers is set.
    
    Data Body content (bytes order is little endian)
    
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  0 |0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  4 |0 0 0 0 0 0 0 1|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|  7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  8 |0 0 0 0 0 0 0 0|0 0 0 0 0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 11
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 12 |0 0 0 0 0 0 0 0|0 0 0 0 0 1 1 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 15
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 16 |0 0 0 0 0 0 0 0|0 0 0 0 0 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 19
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 20 |0 0 0 0 0 0 0 0|0 0 0 0 1 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 23
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 24 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1|0 0 0 0 1 0 0 1|0 0 0 0 0 0 0 0| 27
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 28 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 1 0 1 0|0 0 0 0 0 0 0 0| 31
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 32 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1|0 0 0 0 1 0 1 1| 35
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 36 |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 1| 39
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 40 |0 0 0 0 0 0 0 1|0 0 0 0 1 1 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 43
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 44 |0 0 0 0 0 0 0 0|0 0 0 0 1 1 1 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0| 47
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 48 |0 0 0 0 0 0 0 0|
    +-+-+-+-+-+-+-+-+

    Content description:

      0-3 octets: value of d.a.i
      
      4 octet: 1 - d.a.pi is not nullptr
      
      5-8 octets: value of i1 (dereferenced d.a.pi value)
      
      9-20 octets: value of d.ai
       
      21-24 octets: value of d.aa[0].i
      
      25 octet: 1 - d.aa[0].pi is not nullptr
      
      26-29 octets: value of i2 (dereferenced d.aa[0].pi value)
      
      30-33 octets: value of d.aa[1].i
      
      34 octet: 1 - d.aa[1].pi is not nullptr
      
      35-38 octets: value of i3 (dereferenced d.aa[1].pi value)
      
      39 octet: 1 - d.ppi is not nullptr
      
      40 octet: 1 - *d.ppi (pi) is not nullptr
      
      41-44 octets: value of i4 (doubly dereferenced d.ppi value)
      
      45-48 octets: value of d.j
      
CSP Interfaces
==============

  By CSP Interface we mean the set of structures where every one have
  several mandatory interface properties and several mandatory
  individual properties.  
  
Interface properties
====================
  
  Interface ID
  
    UUIDv4 of the struct interface.  If we say that some instance is supported
    specific Interface of specific version number, than it means that it
    has snapshot of every struct in this Interface that is on that
    version.  And all this structs have this Interface ID.  Cannot be changed.
    
  Version
  
    32 bits field, that represents current version of interface.  Its
    semantic depends on concrete interface.  This is the only field that
    allowed to be changed.
    
  Mandatory data flags
  
    Data flags that are always in use in Serialization of interface
    structs.  Cannot be changed.
    
  Forbidden data flags
  
    Data flags that cannot be used in Serialization of interface
    structs.  Cannot be changed.
  
Structures individual properties
(applied to those that are part of CSP Interface)
=================================================

  Struct ID
  
    UUIDv4 of struct itself. Cannot be changed.
    
  Struct Interface version
  
    Version of interface on which current struct or one of its
    dependecies were changed last time.  Dependencies mean substructs
    (fields) from which this one consists.
    
  Private versions

    An array of interface versions values.  Value is added every time 
    when struct was changed.  Sorted in decreasing order.
    
    By change we mean adding or removing field from struct or from one
    of struct parents (structs are allowed to be inherited), or when one
    of the struct fields changed its type (structure).  It is important
    to note, that only change of field type (structure) is lead to
    Private version update.  If there is internal change of type of
    field struct (update), private version wouldn't change, instead
    interface version is changed.
    
    Because order of fields in Serializable structs is matter, any
    changes of it is also applied to private version update. You are
    strongly discouraged to do so.
    
  Additional mandatory data flags (optional)
  
    Data flags that are always in use in Serialization of this struct.
    It is disjunction of every additional mandatory data flags of every
    struct dependency and struct private restrictions.
    Effective mandatory data flags set is disjunction of mandatory data
    flags and additional mandatory data flags.
    
  Additional forbidden data flags (optional)
  
    Data flags that cannot be used in Serialization of this struct.
    It is disjunction of every additional forbidden data flags of every
    struct dependency and struct private restrictions.
    Effective forbidden data flags set is disjunction of forbidden data
    flags and additional forbidden data flags.
  
Types that are in use in CSP Interfaces
=======================================

  It is important to say that structs in concrete interface are allowed
  to be made of types that are not part of this interface.  And there is
  two distinct scenarios.
  
  First, when type (struct) is not part of any CSP interface - it has no
  CSP Interface properties and it is not allowed to version conversion.
  Also such types cannot be as root struct in CSP Data Message, only as
  field of struct from CSP interface.  Example of such types are
  integers, floating point numbers and any user-defined composite types.
  
  Second, struct from parent interface.  More details will be in 
  Dependent Interfaces section.
  
Dependent Interfaces
====================

  CSP allows to inherit interfaces.  But descendant interfaces are have
  one and only one parent.  It must have the same versioning order as
  parent have.  Start Version property is the same as Struct Interface
  version property of the most recent changed struct from parent
  interface that is a part of derived interface as dependency, or the
  most recent Version property.
  
  Every time when dependency from parent interface is updated Version of
  derived interface must be updated too (and all dependent Struct
  Interface versions).
  
  Derived interface don't allowed to have versions bigger than parent
  interface has, but parent one don't have any such restrictions.  So if
  there is need to add or update any of derived interface struct, and
  the derived interface before this update has the same version as the
  parent one, than need to wait before parent interface will be updated.
      
CSP Interfaces Versioning
=========================

  When struct that is part of current CSP Interface is changed or new
  struct is added, we mean that CSP Interface is changed and this change
  must be happening at the same time as Version of interface increasing.
  Any field or subfield type of CSP Interface struct that is not part of
  this or parent CSP Interfaces must have permanent definition of parts
  that take a part in Serialization.
  
  Example
  
    +-------------------------------------------------------------+
    | Free structs types                                          |
    |                                                             |
    |   Struct P                                                  |
    |     integer i                                               |
    |                                                             |
    |   Struct Q                                                  |
    |     integer i                                               |
    |     Simply_assignable_tag                                   |
    |                                                             |
    | Interface ICsp (version 0)                                  |
    |                                                             |
    |   Struct R                                                  |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     P p                                                     |
    |                                                             |
    |   Struct S                                                  |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     Simply_assignable_tag                                   |
    |                                                             |
    |     Q q                                                     |
    |                                                             |
    |   Struct T inherits R and S                                 |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     integer j                                               |
    |                                                             |
    |   Struct U                                                  |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     T t                                                     |
    |                                                             |
    |   Struct V                                                  |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     array of T t[3]                                         |
    +-------------------------------------------------------------+
      
                                Scheme 8
                                
  Interface ICsp is just now created and have version 0.  On the
  creation time it has only four structs.  Each of them have interface
  versions as 0 and private versions array contain only one element with
  0 as value.
  
  Consider now that we decided to update structs S and V and add struct
  W.
  
    +-------------------------------------------------------------+
    | Free structs types                                          |
    |                                                             |
    |   (the same as in Scheme 8)                                 |
    |                                                             |
    | Interface ICsp (version 1)                                  |
    |                                                             |
    |   Struct R                                                  |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     P p                                                     |
    |                                                             |
    |   Struct S                                                  |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     Q q                                                     |
    |     pointer to integer pi                                   |
    |                                                             |
    |   Struct T inherits R and S                                 |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     integer j                                               |
    |                                                             |
    |   Struct U                                                  |
    |     interface_version 1                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     T t                                                     |
    |                                                             |
    |   Struct V                                                  |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     array of T t[3]                                         |
    |     integer i                                               |
    |                                                             |
    |   Struct W                                                  |
    |     interface_version 1                                     |
    |     private_versions [1]                                    |
    |                                                             |
    |     array of R ar[3]                                        |
    |                                                             |
    | Legacy section of Interface ICsp                            |
    |                                                             |
    |   Struct S_version0                                         |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     Simply_assignable_tag                                   |
    |                                                             |
    |     Q q                                                     |
    |                                                             |
    |   Struct T_version0 inherits R and S_version0               |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     integer j                                               |
    |                                                             |
    |   Struct V_version0                                         |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     array of T_version0 t[3]                                |
    +-------------------------------------------------------------+
      
                                Scheme 9
                                
  As you can see private_versions arrays fields of structs S, T and V
  are additionally populated with 1.  This is because S and V have added
  fields and T is inherited from S.
  
  Interface_version fields of structs S, T, U and V are changed from 0
  to 1.  Structs S, T and V have added fields (or their parents) and
  struct U have dependency as field with type T.  Since type T has
  interface_version of 1, struct U interface_version is also must to
  be that large.
  
  Struct R is not changed itself and it has no dependencies with upper
  interface_versions it own interface_version is also keeped as 0.
  
  Pay attention that struct S now has no Simply_assignable_tag.
  
  To implement backward compatibility we must save previous versions of
  changed structs.  These are the structs that changed their fields
  composition - structs S, T and V (again T is here as it inherited from
  S).  This structs are postfixed with _version0, where '0' is private
  version.  They all placed to Legacy section.
  
  In the next ICsp version we change structs R, U and W.
  
    +-------------------------------------------------------------+
    | Free structs types                                          |
    |                                                             |
    |   (the same as in Scheme 8)                                 |
    |                                                             |
    | Interface ICsp (version 2)                                  |
    |                                                             |
    |   Struct R                                                  |
    |     interface_version 2                                     |
    |     private_versions [2, 0]                                 |
    |                                                             |
    |     P p                                                     |
    |     integer i                                               |
    |                                                             |
    |   Struct S                                                  |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     Q q                                                     |
    |     pointer to integer pi                                   |
    |                                                             |
    |   Struct T inherits R and S                                 |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     integer j                                               |
    |                                                             |
    |   Struct U                                                  |
    |     interface_version 2                                     |
    |     private_versions [2, 0]                                 |
    |                                                             |
    |     integer i                                               |
    |     integer k                                               |
    |     integer j                                               |
    |     pointer to integer pi                                   |
    |                                                             |
    |   Struct V                                                  |
    |     interface_version 1                                     |
    |     private_versions [1, 0]                                 |
    |                                                             |
    |     array of T t[3]                                         |
    |     integer i                                               |
    |                                                             |
    |   Struct W                                                  |
    |     interface_version 2                                     |
    |     private_versions [2, 1]                                 |
    |                                                             |
    |     array of R ar[3]                                        |
    |     integer i                                               |
    |                                                             |
    | Legacy section of Interface ICsp                            |
    |                                                             |
    |   Struct R_version0                                         |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     P p                                                     |
    |                                                             |
    |   Struct S_version0                                         |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     Simply_assignable_tag                                   |
    |                                                             |
    |     Q q                                                     |
    |                                                             |
    |   Struct T_version0 inherits R_version0 and S_version0      |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     integer j                                               |
    |                                                             |
    |   Struct U_version0                                         |
    |     interface_version 1                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     T t                                                     |
    |                                                             |
    |   Struct V_version0                                         |
    |     interface_version 0                                     |
    |     private_versions [0]                                    |
    |                                                             |
    |     array of T_version0 t[3]                                |
    |                                                             |
    |   Struct W_version1                                         |
    |     interface_version 1                                     |
    |     private_versions [1]                                    |
    |                                                             |
    |     array of R_version0 ar[3]                               |
    +-------------------------------------------------------------+
      
                                Scheme 10
                                
  Private_version fields of Structs R, U and W are replenished by
  element with value 2.  Their interface_version fields are now equal to
  2.  Their previous versions are placed to Legacy section.
  
  Since struct R most recent version is changed and previous one is
  placed to Legacy section as R_version0, then we need to replace the
  names of all fields or parent structs that had type R in Legacy
  structs.  In our example this is struct T, that inherited R and now
  is inherits R_version0.
  
  Struct U_version0 have field of type T. Struct T is not changed since
  version 1 and here it implicitly using exact this one.
  
  Struct W_version1 had field of type R, but because it is changed in
  ICsp version 2, type of the field is also changed to R_version0.
  
  You must be curious - why don't we just directly naming structs with
  _versionN suffixes instead of renaming later?  Is there any pitfalls
  in doing such way?
  
  The answer is "yes", there is one pitfall.  If we doing that, with
  each change of one or onother struct in our CSP Interface it would be
  necessary to update any routine, any code that depends on it.
  
  Also there are two far less significant reasons.  First, suffix
  explicitly shows that struct which we are dealing with is legacy.
  Second, it's just not very pretty (in my opinion).
  
Processing of CSP Interface structs conversions
===============================================

  The only reason for keeping legacy versions of structs in interface
  is to have ability to deal with them when version of interface is not
  the most recent one.
  
  There are couple of different situations which we must handle.
  
  1.  Serialization to legacy versions.
    One party converts data to one of the legacy versions and serialized
    it in this form.  This can be the case, when another party that
    participate in deserialization process has lower interface version
    then one has.
    
    Here we must need to have ability to convert struct from highest
    version to legacy one and serialize it in this form.
    
  2.  Deserialization from legacy versions.
    One party serialized data with interface version that is lower then
    another party that participate in deserialization process has.
    
    In such scenario we must have ability to deserialize such legacy
    struct version and convert from it to actual one.  Optionally it is
    not necessary to convert precisely to most recent, but it is a
    default behaviour.
  
  Data Context contains "interface version" field.  This field is
  contain target interface version that would be participate in
  Serialization.  Any value that is higher or equal to Top-struct Struct
  Interface version property means that no conversion need to be
  applied and must be applied otherwise.
  
  One important clarification is that if any party declare that supports
  any specific CSP Interface there is no obligation for that party in
  handling all legacy structs from it.  If any party receives Data
  Message with version that it doesn't want (or can) to handle it must
  return status with ErrorNotSupportedInterfaceVersion value.

  Serialization to legacy versions
  
    1.  Checking of Context interface version.  If it is lower than
      current value of Top-struct interface version field, then we are
      in compatibility ("interface versions not match") mode.  But if it
      is lower than lowest Top-struct private version, then settings are
      incompatible and processing must be stoped.
      
      For example.  If Context interface version is equal to 4, and
      Top-struct private versions array is [7, 6, 3, 2], then 4 is in
      the range [2, 7), so we are in compatibility mode.
      
    Next steps are doing after Data Context fully processed and we start
    serializing Data Body.
      
    2.  Compare Context interface version value against versions of
      current struct private versions array field begining with the most
      recent private version (element with 0 offset in the array).  We
      need to find maximum element of private versions that is equal or
      less than Data Context interface version.
      
      For example.  Let values be as in item 1, then struct private
      version satisfying the above condition is 3.  Because 7 and 6 are
      bigger then 4.
      
    3.  Compare version found in previous item with the latest private
      version of current struct. If they are equal, then go to item 5.
      
    4.  Struct is converted to version that was found at item 2.
      
    5.  If struct have any of Simply Assignable tags and there is no
      Data Flag simply assignable tags optimizations are turned off is
      set, then.
      
      a.  If struct Interface version is bigger then Context interface
        version, then go to item 6.
        
      b.  If Data Flags are compatible with this struct simply
        assignable optimizations (see rules of this type of structs
        serialization), then standard serialization must be performed.
        Then go to next field in item 6 processing of framing struct
        or if current struct is Top-struct already, finish
        serialization.
      
      c.  Else go to item 6.
      
    6.  Struct is serialized field-by-field begining every time from
      item 2 for CSP Interface structs, item 5 for Symply assignable
      stucts and standard serialization is performed with all other
      types.  If current struct is not Top-struct after last field
      is processed processing conitnues with next field in framing 
      struct.  And if it is Top-struct after last field the
      serialization is finished.
      
    Deserialization from legacy versions
    
    First two items are the same as in "Serialization to legacy
    versions" paragraph.
      
    3.  Compare version found in previous item with most latest private
      version of current struct to choose compatible version of struct
      to make deserialization.  If they are equal, then we using most
      recent version of the struct, and if not, Struct will be
      deserialized using legacy version definition before assigning to
      actual one object.

      If we take example from "Serialization to legacy versions" item 1,
      then deserialization of Top-struct will be performed using
      Top-struct_version3 choice.
      
    4.  If struct have any of Simply Assignable tags and there is no
      Data Flag simply assignable tags optimizations are turned off is
      set, then.
      
      a.  If struct Interface version is bigger then Context interface
        version, then go to item 5.
        
       b.  If Data Flags are compatible with this struct simply
        assignable optimizations (see rules of this type of structs
        serialization), then standard serialization must be performed.
        Then go to next field in item 5 processing of framing struct
        or if current struct is Top-struct already then go to item 6.
      
      c.  Else go to item 5.
      
    5.  Struct is serialized field-by-field begining every time from
      item 2 for CSP Interface structs, item 4 for Simply assignable
      stucts and standard serialization is performed with all other
      types.  After final field of current struct is finished go to
      item 6 if this struct is part of CSP Interface and to framing
      struct if it is not.
      
    6.  If this struct version is not the latest one then it must be
      converted and then assigned to actual object to which we
      deserializing.  If this struct is Top-struct, deserialization is
      finished now and if it is not, then go to next field in item 5 of
      framing struct.
      
CSP Messaging
=============

  There are two participants in Messaging process: Client and Server.
  
  Client
  
    Sends requests to Server and receives responses from it.
  
  Server
  
    Receives requests from Client and responses them.
    
    The main requests is Data Messages.  According to Top-struct in Data
    Message server choose handler(s) to process it.
    
    Handler is the routine that receives struct that part of Interface
    as input and returns another one as output to Client if need.  Both
    structs must be from one CSP interface.  The only exception from
    this rule is when output struct is instance of Dummy from CSP
    Service structs interface.
    
    Handler types:
    
      unicast: Server can have only one routine where concrete
        Top-struct is input struct;
        
      multicast: Server may have any count of routines where concrete
        Top-struct is input struct, but every such routine must have
        no output struct.
    
    Server and any distinct handler may also contain security related
    procedures to check rights of particular Client against its request,
    but it is not mandatory and not part of CSP.

  Properties of Client and Server
  
    Every instance of Client and Server must have several mandatory
    properties:
    
      supported CSP versions;
      mandatory common flags;
      forbidden common flags;
      list of supported CSP Interfaces with their versions.
      
    It is strongly recommended that Servers are using common flags that
    are related to platform on which they running.
    
  Initializing of Client instance
  
    There are two options:
    
      1. Client applies some predefined settings (properties).
        
      2. Client requests settings from particular Server and applies
        them with respect to settings appropriate for itself.
        
    Standard order of operations of second option:
    
      - Client sends pseudo-message with only Common Context included,
        and with Protocol Version Undefined in CSP Version field;
        
      - Server answers with Status Message 
        ErrorNotSupportedProtocolVersion;
        
      - Client choose prefered version from received from Server;
      
      - Client sends GetSettings Message using protocol version
        choosed on previous step;
      
      - Server answers with Data Message where Top-struct is
        CspPartySettings struct (see CSP Service Structs interface
        section);
        
      - Client choose compatible settings according to received one to
        talk with Server.
        
  Initializing of Server instance
  
    Server applies some predefined settings.
        
CSP Service Structs Interface
=============================

  It is the mandatory interface that must be implemented by every CSP
  instance.  Its version is equal to protocol version.
  
  This interface using in Messaging process.
  
  Properties:
  
    Interface ID: 47be322-232e-4d66-9175-06eed2110b4b
    Version: corespond to CSP protocol version
    Mandatory data flags: empty
    Forbidden data flags: SizeOfIntegersMayBeNotEqual,
      AllowUnmanagedPointers, CheckRecursivePointers
  
  Structs included in Version 1:
  
    Dummy
    
      Interface ID: 60b0dd3e-7d2e-42d9-b00d-90f7ecd19d25
      Fields: empty
      Description: placeholder for absent struct.  Primarily using as
        Output struct type when in response need Status of operation.
        
    GetInterface
        
      Interface ID: 08c68657-4fa7-4419-8c13-66aec2b06cb0
      Fields:
        Id: GUIDv4 of CSP Interface
      Description: sends for request of Interface propreties
      
    OutGetInterface
    
      Interface ID: 22bd67db-65a0-42f4-b28b-63c6181aebe1
      Fields:
        Id: GUIDv4 of CSP Interface
        Interface version: Version of interface
        Mandatory Data flags: Mandatory data flags of interface
        Forbidden Data flags: Forbidden data flags of interface
        
        Note: these 4 fields may also be named as Interface Properties
        struct
      Description: sends in response of GetInterface.
      
    InterfaceVersion
    
      Interface ID: df1cb40c-9a72-426b-a801-b0993fe76a46
      Fields:
        Id: GUIDv4 of CSP Interface
        Interface version: Version of interface
    
    CspPartySettings
    
      Interface ID: bf8c27e8-fe6a-4492-91cb-e4cf411e1236
      Fields:
        Count of CSP versions: count of versions in the next field, as
          size_t
        CSP versions: array of versions of CSP protocol in decreasing
          order
        Mandatory Common flags: Mandatory common flags
        Forbidden Common flags: Forbidden common flags
        Count of CSP Interfaces: count of versions in the next field, as
          size_t
        CSP Interfaces: array of InterfaceVersion structs

      Description: contain supported settings of CSP party (Client or
        Server).  Sends in response of GetSettings Message.        
        
========================================================================
========================================================================
========================================================================
     
Copyright (c) 2023-2024 Andrey Grabov-Smetankin <ukbpyh@gmail.com>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
